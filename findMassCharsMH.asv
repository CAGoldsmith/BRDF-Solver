function [I, segM] = findMassCharsMH()

%Clarissa Goldsmith
%West Virginia University

%This script runs independently of the rest of design_drosophibot, with the
%intent that you find the CoMs and overall masses with the script, then plug in the
%results in the Animatlab file

%% ASSUMPTIONS/DEFINITIONS
%Current leg design for the middle/hind has the coxa as all actuator, the trochanter as all
%plastic, the femur as two actuators with plastic, and the tibia and tarsus
%as all plastic

%Current leg design also uses MX-28 actuators with the following
%parameters:
actuator.mass = 82.7/1000; %kg - MX-28T
actuator.length = 50.6/1000; %m
actuator.width = 35.5/1000; %m
actuator.height = 35.6/1000; %m
actuator.hornWidth = 40/1000; %m
actuator.hornCOMLength = 16.1/1000; %m
actuator.I = 0.00943;

%Segment lengths are:
segL = [13; 24; 100; 100; 100]/1000; %m
plasL = [0; 24; 41.3; 100; 100]/1000; %m

%Other dimensions of the plastic are:
%This takes the most "prevalent" dimension for each
plasW = [0; 50; 25.4; 25.4; 25.4]/1000;
plasH = [0; 23.8; 50.8; 25.4; 25.4]/1000;

%Segment masses are:
plasM = [0; 6.4; 18.7; 29.7; 25.2]/1000; %kg
segM = [actuator.mass; plasM(2); actuator.mass*2 + plasM(3); plasM(4); plasM(5)]; %kg



%% Find the CoM of each segment

%The CoM of the plastic pieces, according to solidworks and assuming that
%they have roughly uniform density
%Measured from the location of the most proximal attachment point of the
%segment
plasCOM = [0, 0.81, 2.60, 4.87, 3.15;...
            0, 0.00, 1.26, 0.00, 0.00;...
            0, 0.00, 0.00, 0.00, 0.00]/100;
        
%The CoM of each segment, with reference to the most proximal joint it
%attaches to
COMjr(:,1) = [segL(1)-actuator.length/2; 0; 0];

COMjr(:,2) = plasCOM(:,2);

COMjr(1,3) = (actuator.hornWidth/2*actuator.mass + (actuator.hornWidth + plasCOM(1,3))*plasM(3) +...
    (actuator.hornWidth + plasL(3) + actuator.height/2)*actuator.mass)/segM(3);   

COMjr(2,3) = (-actuator.length/2*actuator.mass + plasCOM(2,3)*plasM(3) + actuator.length/2*actuator.mass)/segM(3);

COMjr(3,3) = 0;

COMjr(:,4) = plasCOM(:,4);

COMjr(:,5) = plasCOM(:,5);

%Convert these into CoMs based on the origin of each body in Animatlab
for i=1:length(COMjr)
    COMor(:,i) = COMjr(:,i) - [segL(i)/2; 0; 0];
end

%% Compute the moments of inertia for each segment

%COXA:
%Start with the moments of inertia
I_coxa(1,1) = 1/12 * actuator.mass * (actuator.height^2 + actuator.hornWidth^2); %Ixx
I_coxa(2,2) = 1/12 * actuator.mass * (actuator.length^2 + actuator.hornWidth^2); %Iyy   
I_coxa(3,3) = 1/12 * actuator.mass * (actuator.height^2 + actuator.length^2); %Izz

%Then, the products of inertia
%All products of inertia for the coxa are zero

%TROCHANTER:
%Moments of inertia:
I_troc(1,1) = 1/12 * plasM(2) * (plasW(2)^2 + plasH(2)^2);
I_troc(2,2) = 1/12 * plasM(2) * (plasW(2)^2 + plasL(2)^2);
I_troc(3,3) = 1/12 * plasM(2) * (plasL(2)^2 + plasH(2)^2) + actuator.I;

%Product of inertia:
%All products of inertia for the trochanter are zero

%FEMUR
%This one is the bear
%Moments of inertia:
I_fem(1,1) = (1/12 * actuator.mass * (actuator.height^2 + actuator.length^2) +... %I about CoM for medial actuator 
    actuator.mass * norm([-actuator.length/2; 0])^2 +... %parallel axis thm for medial actuator
    1/12 * plasM(3) * (plasW(3)^2 + plasH(3)^2) +... %I abt CoM for plastic
    plasM(3) * norm([plasCOM(2,3);0])^2 +... %parallel axis thm for plastic
    1/12 * actuator.mass * (actuator.hornWidth^2 + actuator.length^2) +...%I abt CoM for lateral actuator
    actuator.mass * norm([actuator.length/2; 0])^2) -...%parallel axis thm for lateral actuator
    (segM(3) * norm(COMjr(2:3,3))^2); %paral

I_fem(2,2) = (1/12 * actuator.mass * (actuator.hornWidth^2 + actuator.height^2) +...
    actuator.mass * norm([actuator.hornWidth/2; 0])^2 +...
    1/12 * plasM(3) * (plasW(3)^2 + plasL(3)^2)^2 +...
    plasM(3) * norm([actuator.hornWidth + plasCOM(1,3); 0])^2 +...
    1/12 * actuator.mass * (actuator.hornWidth^2 + actuator.height^2) +...
    actuator.mass * norm([actuator.hornWidth + plasL(3) + actuator.height/2; 0])^2) -...
    (segM(3)* norm([COMjr(1,3); COMjr(3,3)])^2);

I_fem(3,3) = (1/12 * actuator.mass * (actuator.length^2 + actuator.hornWidth^2) +...
    actuator.mass * norm([actuator.hornWidth/2; -actuator.length/2])^2 +...
    1/12 * plasM(3) * (plasL(3)^2 + plasH(3)^2) +...
    plasM(3) * norm([actuator.hornWidth + plasCOM(1,3); plasCOM(2,3)])^2 +...
    1/12 * actuator.mass * (actuator.length^2 + actuator.height^2) +...
    actuator.mass * norm([actuator.hornWidth + plasL(3) + actuator.height/2; actuator.length/2])^2) -...
    segM(3) * norm(COMjr(1:2,3))^2;

%Products of inertia:
I_fem(2,1) = actuator.mass * -(segL(3)/2 - actuator.hornWidth/2) * -actuator.length/2 +...
    segM(3) * (actuator.hornWidth + 2.04/100 - segL(3)/2) * plasCOM(2,3) +...
    actuator.mass * (segL(3)/2 - actuator.hornWidth/2) * actuator.length/2;
I_fem(1,2) = I_fem(2,1);

%Other products of inertia should be zero, as the z coord of the CoM
%doesn't leave the x-axis for any of the portions of the segment


%TIBIA
%Moments of Inertia:
I_tib(1,1) = 1/12 * segM(4) * (plasW(4)^2 + plasH(4)^2);
I_tib(2,2) = 1/12 * segM(4) * (plasL(4)^2 + plasW(4)^2);
I_tib(3,3) = 1/12 * segM(4) * (plasL(4)^2 + plasH(4)^2);

%Products of inertia: All are zero

%TARSUS
%Moments of inertia:
I_tar(1,1) = 1/12 * segM(5) * (plasW(5)^2 + plasH(5)^2);
I_tar(2,2) = 1/12 * segM(5) * (plasL(5)^2 + plasW(5)^2);
I_tar(3,3) = 1/12 * segM(5) * (plasL(5)^2 + plasH(5)^2);

%Products of inertia: All are zero

I = {I_coxa; I_troc; I_fem; I_tib; I_tar};


